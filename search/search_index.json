{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hyperledger Blockchain Performance This site represents a collaborative collection and presentation of Hyperledger Blockchain performance reports, using the metrics defined within the Hyperledger Performance and Scale Working Group's white paper titled Hyperledger Blockchain Performance Metrics and generated using Hyperledger Caliper. Contained reports are intended to provide key processing and performance characteristics to architects, systems programmers, analysts and programmers. For best use of the performance reports, the user should be familiar with the concepts and operation of the technology under test. Within this site you will find performance reports for Hyperledger Blockchain technologies covering: API tests: Deep dive investigation into the performance implications of API useage for a specific Hyperledger technology Sample tests: A test that is focussed on a sample provided for a specific Hyperledger technology Scenario tests: A test that involves the completion of a task, and is applicable to all Hyperledger technologies All test resources used to generate the contained reports are available within the Caliper Benchmarks repository Notes The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform under test. The data contained in listed reports were measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources section at the end of all available reports. The performance data cannot be compared across versions of a blockchain technology, as testing hardware and environments may be significantly different. The testing contents and processing methodologies may have also changed between performance reports, and so these cannot be compared.","title":"Overview"},{"location":"#hyperledger-blockchain-performance","text":"This site represents a collaborative collection and presentation of Hyperledger Blockchain performance reports, using the metrics defined within the Hyperledger Performance and Scale Working Group's white paper titled Hyperledger Blockchain Performance Metrics and generated using Hyperledger Caliper. Contained reports are intended to provide key processing and performance characteristics to architects, systems programmers, analysts and programmers. For best use of the performance reports, the user should be familiar with the concepts and operation of the technology under test. Within this site you will find performance reports for Hyperledger Blockchain technologies covering: API tests: Deep dive investigation into the performance implications of API useage for a specific Hyperledger technology Sample tests: A test that is focussed on a sample provided for a specific Hyperledger technology Scenario tests: A test that involves the completion of a task, and is applicable to all Hyperledger technologies All test resources used to generate the contained reports are available within the Caliper Benchmarks repository","title":"Hyperledger Blockchain Performance"},{"location":"#notes","text":"The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform under test. The data contained in listed reports were measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources section at the end of all available reports. The performance data cannot be compared across versions of a blockchain technology, as testing hardware and environments may be significantly different. The testing contents and processing methodologies may have also changed between performance reports, and so these cannot be compared.","title":"Notes"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and (c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"{}\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright {yyyy} {name of copyright owner} Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"common/inprogress/","text":"Page In Progress We are working on content for this location ... please check back later, or help us build it!","title":"Tools"},{"location":"common/inprogress/#page-in-progress","text":"We are working on content for this location ... please check back later, or help us build it!","title":"Page In Progress"},{"location":"community/chat/","text":"Rocket Chat You can find us on the following Rocket Chat channels: Caliper Performance and Scale Workgroup","title":"RocketChat"},{"location":"community/chat/#rocket-chat","text":"You can find us on the following Rocket Chat channels: Caliper Performance and Scale Workgroup","title":"Rocket Chat"},{"location":"community/contribute/","text":"Contribute Happy to see you here and reading the contribution section! We are looking to expand the number of repeatable test cases and subsequent analysis contained in this site - if you have an item to contribute, or are looking to contribute, then please reach out to us.","title":"Contribute"},{"location":"community/contribute/#contribute","text":"Happy to see you here and reading the contribution section! We are looking to expand the number of repeatable test cases and subsequent analysis contained in this site - if you have an item to contribute, or are looking to contribute, then please reach out to us.","title":"Contribute"},{"location":"fabric/downloads/","text":"The reports contained in this site are available for download in pdf format from the table below Fabric Version Smart Contract SDK Client Link 1.4.0 JavaScript NodeJS pdf report","title":"Download"},{"location":"fabric/performance/","text":"Hyperledger Fabric performance observations are obtained from testing smart contracts, driven by Fabric-SDK-Node clients through a series of benchmarks. The benchmarks use a single machine test topology with an orderer and two peers, as depicted in Figure 1 below: Figure 1: Test Topology During benchmarking, all transactions are driven via a Hyperledger Fabric client gateway. Throughput and latencies for each benchmark are measured, as are resource statistics during the benchmark process. The benchmarks utilize a single machine test topology for ease of test recreation. You can expect higher throughput if you were to use dedicated hardware for each peer and orderer node. The Smart Contract All benchmarks are facilitated by the fixed-asset smart contract that is deployed to the Hyperledger Fabric network. The smart contract facilitates the driving of core API methods that are commonly used by a smart contract developer. Smart Contract Method Description emptyContract Immediately returns an empty response and represents the minimum possible overhead incurred through evaluation or submission of a smart contract method via a gateway. createAsset Performs a single putState() operation, inserting an asset of defined byte size into the World State database. createAssetsFromBatch Performs multiple putState() operations over an array of assets, inserting each into the World State database. createPrivateAsset Performs a single putPrivateData() operation, inserting an asset of defined byte size into the Private Data collection of the authorized organization. deleteAsset Performs a single deleteState() operation, removing a single asset from the World State database using a passed UUID. deleteAssetFromBatch Performs multiple deleteState() operations over an array of asset UUIDs, removing all assets from the World State database. getAsset Performs a single getState() operation, extracting and returning a single asset from the World State database using a passed UUID. getAssetsFromBatch Performs multiples getState() operations over an array of asset UUIDs, extracting and returning all asset from the World State database. getPrivateAsset Performs a single getPrivateData() operation, extracting and returning a single asset from the Private Data Collection of the authorized organization using a passed UUID. paginatedRangeQuery Performs a getStateByRangeWithPagination() operation, based on passed start/end keys, a desired page size and passed bookmark. The records obtained from the query are processed and returned in a JSON response that also includes a new bookmark. paginatedRichQuery Performs a getQueryResultWithPagination() operation, based on a passed Mango query string, a desired page size and bookmark. The records obtained from the query are processed and returned in a JSON response that also includes a new bookmark. Only valid for deployments including a CouchDB World State database. Smart contract methods may be evaluated or submitted via a Fabric Network gateway. An overview of possible transaction pathways from a client application interacting with Hyperedger Fabric is presented in Figure 1. Evaluation of a smart contract method will not include interaction with the ordering service, and consequently will not result in appending to the leger; submission of a smart contract will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the ordering service. Figure 1: Possible Transaction Pathways Smart Contract Benchmarks The complete output of the benchmark runs, and the resources used to perform them, are in the resources section of the Appendix. All benchmarks are driven at maximum possible TPS for a duration of 5 minutes by multiple test clients. This is followed by a driving the benchmarks at a set TPS for a duration of 5 minutes by multiple test clients to enable resource utilization comparisons. The benchmarks comprise of: Benchmark Config Files Description Empty Contract empty-contract-1of.yaml, empty-contract-2of.yaml Evaluates and submits emptyContract gateway transactions for the fixed-asset smart contract. This transaction performs no action. Repeated for different Endorsement Policies. Create Asset create-asset.yaml Submits createAsset gateway transactions for the fixed-asset smart contract. Each transaction inserts a single asset into the world state database. Successive rounds increase the asset byte size inserted into the world state database. Create Asset Batch create-asset-batch.yaml Submits createAssetsFromBatch gateway transactions for the fixed-asset smart contract. Each transaction inserts a sequence of fixed size assets into the world state database. Successive rounds increase the batch size of assets inserted into the world state database. Create Private Asset create-private-asset.yaml Submits createPrivateAsset gateway transactions for the fixed-asset smart contract. Each transaction inserts a single asset into the Private Data Collection of the authorized organization. Successive rounds increase the asset byte size inserted into the Private Data Collection. Delete Asset delete-asset.yaml Submits deleteAsset gateway transactions for the fixed-asset smart contract. Each transaction removes a single asset from the world state database. Successive rounds increase the asset byte size removed from the world state database. Delete Asset Batch delete-asset-batch.yaml Submits deleteAssetsFromBatch gateway transactions for the fixed-asset smart contract. Each transaction removes a series of assets from the world state database. Successive rounds increase the batch size of assets removed from the world state database. Get Asset get-asset.yaml Evaluates getAsset gateway transactions for the fixed-asset smart contract. Each transaction retrieves a single asset from the world state database. Successive rounds increase the asset byte size retrieved from the world state database. Get Asset Batch get-asset-batch.yaml Evaluates getAssetsFromBatch gateway transactions for the fixed-asset smart contract. Each transaction retrieves a series of assets from the world state database. Successive rounds increase the batch size of assets retrieved from the world state database. Get Private Asset get-private-asset.yaml Evaluate getPrivateAsset gateway transactions for the fixed-asset smart contract. Each transaction retrieves a single asset from the Private Data Collection of the authorized organization. Successive rounds increase the asset byte size retrieved from the Private Data Collection. Paginated Range Query mixed-range-query-pagination.yaml Evaluates paginatedRangeQuery gateway transactions for the fixed-asset smart contract. Each transaction retrieves a set of assets from the world state database. Successive rounds increase the page size of assets retrieved from the world state database. Paginated Rich Query mixed-rich-query-pagination.yaml Evaluates paginatedRichQuery gateway transactions for the fixed-asset smart contract. Each transaction retrieves a set of assets from the world state database. Successive rounds increase the page size of assets retrieved from the world state database. Benchmark Results Benchmark results are available for the following: Fabric Version Smart Contract SDK Client Link 1.4.0 JavaScript NodeJS Result 2.0.0 JavaScript NodeJS Result 2.1.0 JavaScript NodeJS Result 2.1.0 Go NodeJS Result Notes The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Performance"},{"location":"fabric/performance/#the-smart-contract","text":"All benchmarks are facilitated by the fixed-asset smart contract that is deployed to the Hyperledger Fabric network. The smart contract facilitates the driving of core API methods that are commonly used by a smart contract developer. Smart Contract Method Description emptyContract Immediately returns an empty response and represents the minimum possible overhead incurred through evaluation or submission of a smart contract method via a gateway. createAsset Performs a single putState() operation, inserting an asset of defined byte size into the World State database. createAssetsFromBatch Performs multiple putState() operations over an array of assets, inserting each into the World State database. createPrivateAsset Performs a single putPrivateData() operation, inserting an asset of defined byte size into the Private Data collection of the authorized organization. deleteAsset Performs a single deleteState() operation, removing a single asset from the World State database using a passed UUID. deleteAssetFromBatch Performs multiple deleteState() operations over an array of asset UUIDs, removing all assets from the World State database. getAsset Performs a single getState() operation, extracting and returning a single asset from the World State database using a passed UUID. getAssetsFromBatch Performs multiples getState() operations over an array of asset UUIDs, extracting and returning all asset from the World State database. getPrivateAsset Performs a single getPrivateData() operation, extracting and returning a single asset from the Private Data Collection of the authorized organization using a passed UUID. paginatedRangeQuery Performs a getStateByRangeWithPagination() operation, based on passed start/end keys, a desired page size and passed bookmark. The records obtained from the query are processed and returned in a JSON response that also includes a new bookmark. paginatedRichQuery Performs a getQueryResultWithPagination() operation, based on a passed Mango query string, a desired page size and bookmark. The records obtained from the query are processed and returned in a JSON response that also includes a new bookmark. Only valid for deployments including a CouchDB World State database. Smart contract methods may be evaluated or submitted via a Fabric Network gateway. An overview of possible transaction pathways from a client application interacting with Hyperedger Fabric is presented in Figure 1. Evaluation of a smart contract method will not include interaction with the ordering service, and consequently will not result in appending to the leger; submission of a smart contract will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the ordering service. Figure 1: Possible Transaction Pathways","title":"The Smart Contract"},{"location":"fabric/performance/#smart-contract-benchmarks","text":"The complete output of the benchmark runs, and the resources used to perform them, are in the resources section of the Appendix. All benchmarks are driven at maximum possible TPS for a duration of 5 minutes by multiple test clients. This is followed by a driving the benchmarks at a set TPS for a duration of 5 minutes by multiple test clients to enable resource utilization comparisons. The benchmarks comprise of: Benchmark Config Files Description Empty Contract empty-contract-1of.yaml, empty-contract-2of.yaml Evaluates and submits emptyContract gateway transactions for the fixed-asset smart contract. This transaction performs no action. Repeated for different Endorsement Policies. Create Asset create-asset.yaml Submits createAsset gateway transactions for the fixed-asset smart contract. Each transaction inserts a single asset into the world state database. Successive rounds increase the asset byte size inserted into the world state database. Create Asset Batch create-asset-batch.yaml Submits createAssetsFromBatch gateway transactions for the fixed-asset smart contract. Each transaction inserts a sequence of fixed size assets into the world state database. Successive rounds increase the batch size of assets inserted into the world state database. Create Private Asset create-private-asset.yaml Submits createPrivateAsset gateway transactions for the fixed-asset smart contract. Each transaction inserts a single asset into the Private Data Collection of the authorized organization. Successive rounds increase the asset byte size inserted into the Private Data Collection. Delete Asset delete-asset.yaml Submits deleteAsset gateway transactions for the fixed-asset smart contract. Each transaction removes a single asset from the world state database. Successive rounds increase the asset byte size removed from the world state database. Delete Asset Batch delete-asset-batch.yaml Submits deleteAssetsFromBatch gateway transactions for the fixed-asset smart contract. Each transaction removes a series of assets from the world state database. Successive rounds increase the batch size of assets removed from the world state database. Get Asset get-asset.yaml Evaluates getAsset gateway transactions for the fixed-asset smart contract. Each transaction retrieves a single asset from the world state database. Successive rounds increase the asset byte size retrieved from the world state database. Get Asset Batch get-asset-batch.yaml Evaluates getAssetsFromBatch gateway transactions for the fixed-asset smart contract. Each transaction retrieves a series of assets from the world state database. Successive rounds increase the batch size of assets retrieved from the world state database. Get Private Asset get-private-asset.yaml Evaluate getPrivateAsset gateway transactions for the fixed-asset smart contract. Each transaction retrieves a single asset from the Private Data Collection of the authorized organization. Successive rounds increase the asset byte size retrieved from the Private Data Collection. Paginated Range Query mixed-range-query-pagination.yaml Evaluates paginatedRangeQuery gateway transactions for the fixed-asset smart contract. Each transaction retrieves a set of assets from the world state database. Successive rounds increase the page size of assets retrieved from the world state database. Paginated Rich Query mixed-rich-query-pagination.yaml Evaluates paginatedRichQuery gateway transactions for the fixed-asset smart contract. Each transaction retrieves a set of assets from the world state database. Successive rounds increase the page size of assets retrieved from the world state database.","title":"Smart Contract Benchmarks"},{"location":"fabric/performance/#benchmark-results","text":"Benchmark results are available for the following: Fabric Version Smart Contract SDK Client Link 1.4.0 JavaScript NodeJS Result 2.0.0 JavaScript NodeJS Result 2.1.0 JavaScript NodeJS Result 2.1.0 Go NodeJS Result","title":"Benchmark Results"},{"location":"fabric/performance/#notes","text":"The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Notes"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/configuration/","text":"This report was generated using the following Hyperledger Fabric component levels: Fabric images: 1.4.0 Fabric chaincode:1.4.0 Fabric SDK Node: 1.4.0 Machine Configuration Hyperledger Caliper at commit level 4156c4da7105fd1c2b848573a9943bfc9900becb was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Ubuntu 16.04-64 RAM: 2x16GB Micron 16GB DDR4 2Rx8 Processor: 3.8GHz Intel Xeon-KabyLake (E3-1270-V6-Quadcore) Motherboard: Lenovo Systemx3250-M6 Firmaware: M3E124G 2.10 10-12-2017 Network Card: Silicom PE310G4i40-T HDD: 960GB SanDisk CloudSpeed 1000 SSD Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 Notes The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Configuration"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/configuration/#machine-configuration","text":"Hyperledger Caliper at commit level 4156c4da7105fd1c2b848573a9943bfc9900becb was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Ubuntu 16.04-64 RAM: 2x16GB Micron 16GB DDR4 2Rx8 Processor: 3.8GHz Intel Xeon-KabyLake (E3-1270-V6-Quadcore) Motherboard: Lenovo Systemx3250-M6 Firmaware: M3E124G 2.10 10-12-2017 Network Card: Silicom PE310G4i40-T HDD: 960GB SanDisk CloudSpeed 1000 SSD Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1","title":"Machine Configuration"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/configuration/#notes","text":"The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Notes"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/batch-get-asset/","text":"The batch asset retrieval benchmark consists of evaluating getAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a set of assets, formed by a randomised selection of available UUIDs, from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog for each of the test clients. Successive rounds increase the batch size of the assets retrieved from the world state database with a fixed asset size of 8Kb. Resource utilization is investigated for a fixed transaction rate of 30TPS and a batch size of 20 assets, each of size 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.20 0.06 408.7 10 0.48 0.29 75.5 20 1.03 0.56 39.0 30 1.34 0.80 27.9 40 1.68 1.05 21.2 50 2.14 1.29 17.8 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.15 0.03 388.9 10 0.46 0.18 68.5 20 0.64 0.32 35.6 30 0.84 0.46 24.2 40 1.10 0.60 18.5 50 1.32 0.74 14.9 Resource Utilization- Batch Size 20 @30TPS Benchmark Observations Use of a LevelDB world state enables higher throughput compared to CouchDB, though this occurs with higher latencies for each transaction. In comparing a LevelDB world state database with a CouchDB equivalent during batch retrieve, there are similarities with the Get Asset Benchmark : implementing a CouchDB incurs a greater CPU and network I/O cost without alleviating CPU utilization of the peer.","title":"Batch Get Asset"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/batch-get-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.20 0.06 408.7 10 0.48 0.29 75.5 20 1.03 0.56 39.0 30 1.34 0.80 27.9 40 1.68 1.05 21.2 50 2.14 1.29 17.8 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.15 0.03 388.9 10 0.46 0.18 68.5 20 0.64 0.32 35.6 30 0.84 0.46 24.2 40 1.10 0.60 18.5 50 1.32 0.74 14.9 Resource Utilization- Batch Size 20 @30TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/batch-get-asset/#benchmark-observations","text":"Use of a LevelDB world state enables higher throughput compared to CouchDB, though this occurs with higher latencies for each transaction. In comparing a LevelDB world state database with a CouchDB equivalent during batch retrieve, there are similarities with the Get Asset Benchmark : implementing a CouchDB incurs a greater CPU and network I/O cost without alleviating CPU utilization of the peer.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/empty-contract/","text":"The Empty Contract Benchmark consists of evaluating emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. This will result on the transaction being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 15 transactions for each of the test clients. Resource utilization is investigated for fixed TPS rate of 750TPS. Benchmark Results LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.18 0.04 792.3 evaluate 2-of-any 0.18 0.04 796.4 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.16 0.04 789.9 evaluate 2-of-any 0.17 0.04 797.5 LevelDB Resource Utilization\u2013 Evaluate By Policy @750TPS CouchDB Resource Utilization\u2013 Evaluate By Policy @750TPS Resource Utilization\u2013 Evaluate 1ofAny Policy @750TPS Resource Utilization\u2013 Evaluate 2ofAny Policy @750TPS Benchmark Observations With a fixed world state database, the endorsement policy has no impact on the consumed resources when evaluating gateway transactions. In comparing a LevelDB world state database with a CouchDB equivalent, there is no appreciable difference in the achievable transaction throughput or transaction latency, nor the CPU or network I/O consumed by either implementation when varying the endorsement policy. There is a slight cost in additional memory requirements for the use of a CouchDB world state store.","title":"Empty Contract"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/empty-contract/#benchmark-results","text":"LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.18 0.04 792.3 evaluate 2-of-any 0.18 0.04 796.4 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.16 0.04 789.9 evaluate 2-of-any 0.17 0.04 797.5 LevelDB Resource Utilization\u2013 Evaluate By Policy @750TPS CouchDB Resource Utilization\u2013 Evaluate By Policy @750TPS Resource Utilization\u2013 Evaluate 1ofAny Policy @750TPS Resource Utilization\u2013 Evaluate 2ofAny Policy @750TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/empty-contract/#benchmark-observations","text":"With a fixed world state database, the endorsement policy has no impact on the consumed resources when evaluating gateway transactions. In comparing a LevelDB world state database with a CouchDB equivalent, there is no appreciable difference in the achievable transaction throughput or transaction latency, nor the CPU or network I/O consumed by either implementation when varying the endorsement policy. There is a slight cost in additional memory requirements for the use of a CouchDB world state store.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/get-asset/","text":"The asset retrieval benchmark consists of evaluating getAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a single asset with a randomised UUID from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog for each of the test clients. Successive rounds increase the size of the asset retrieved from the world state database. Resource utilization is investigated for a fixed transaction rate of 350TPS, retrieving assets of size 8Kb. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.34 0.05 636.0 1k 0.21 0.06 611.1 2k 0.23 0.06 579.8 4k 0.20 0.07 516.8 8k 0.19 0.08 423.1 16k 0.24 0.11 293.6 32k 0.35 0.18 186.5 64k 0.73 0.35 96.0 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.10 0.06 567.4 1K 1.06 0.07 558.9 2K 0.24 0.07 531.4 4K 0.25 0.08 478.0 8K 0.26 0.09 395.4 16K 0.29 0.12 306.1 32K 0.36 0.17 208.3 64K 0.75 0.35 107.0 Resource Utilization- 8k Assets @350TPS Benchmark Observations The CouchDB world state database is observed to achieve comparable throughput and lower latencies than a LevelDB equivalent, with higher achievable TPS for assets that are larger than 10Kb. In comparing a LevelDB world state database with a CouchDB equivalent during asset retrieval, both consume similar memory resources, though the CouchDB world state database results in greater network I/O and a CPU overhead for the CouchDB instance that is not offset at the peer.","title":"Get Asset"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/get-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.34 0.05 636.0 1k 0.21 0.06 611.1 2k 0.23 0.06 579.8 4k 0.20 0.07 516.8 8k 0.19 0.08 423.1 16k 0.24 0.11 293.6 32k 0.35 0.18 186.5 64k 0.73 0.35 96.0 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.10 0.06 567.4 1K 1.06 0.07 558.9 2K 0.24 0.07 531.4 4K 0.25 0.08 478.0 8K 0.26 0.09 395.4 16K 0.29 0.12 306.1 32K 0.36 0.17 208.3 64K 0.75 0.35 107.0 Resource Utilization- 8k Assets @350TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/get-asset/#benchmark-observations","text":"The CouchDB world state database is observed to achieve comparable throughput and lower latencies than a LevelDB equivalent, with higher achievable TPS for assets that are larger than 10Kb. In comparing a LevelDB world state database with a CouchDB equivalent during asset retrieval, both consume similar memory resources, though the CouchDB world state database results in greater network I/O and a CPU overhead for the CouchDB instance that is not offset at the peer.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/paginated-range-query/","text":"The paginated range query benchmark consists of evaluating paginatedRangeQuery gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that use a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog for each of the test clients. Successive rounds increase the page size of assets retrieved from the world state database. Resource utilization is investigated for a fixed transaction rate of 30TPS and a batch size of 20 assets. Benchmark Results LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.23 0.16 81.1 20 0.37 0.26 34.0 50 0.86 0.64 11.2 100 1.59 1.23 6.8 200 2.86 2.40 3.6 500 9.02 7.07 0.9 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.94 0.42 82.1 20 1.60 0.75 45.9 50 4.09 1.84 19.4 100 8.03 3.57 9.7 200 16.55 5.32 5.0 500 15.96 4.80 1.6 Resource Utilization- Batch Size 20 @30TPS Benchmark Observations Use of a CouchDB world state database enables greater throughput but higher latencies than the LevelDB equivalent. In comparing the resource utilization of a LevelDB world state database with a CouchDB equivalent during a range query, the CouchDB world state incurs a cost in memory, network I/O and CPU utilization. In particular, use of a CouchDB world state for a range query is observed to result in significant increases in CPU and memory utilization in the peer, with an associated increase in network I/O as a result of communication with the CouchDB instance. When comparing the range query page sizes against a matching batch size in the Get Asset Batch Benchmark , it is observed to be more efficient to use a batch retrieval mechanism with known UUIDs.","title":"Paginated Range Query"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/paginated-range-query/#benchmark-results","text":"LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.23 0.16 81.1 20 0.37 0.26 34.0 50 0.86 0.64 11.2 100 1.59 1.23 6.8 200 2.86 2.40 3.6 500 9.02 7.07 0.9 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.94 0.42 82.1 20 1.60 0.75 45.9 50 4.09 1.84 19.4 100 8.03 3.57 9.7 200 16.55 5.32 5.0 500 15.96 4.80 1.6 Resource Utilization- Batch Size 20 @30TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/paginated-range-query/#benchmark-observations","text":"Use of a CouchDB world state database enables greater throughput but higher latencies than the LevelDB equivalent. In comparing the resource utilization of a LevelDB world state database with a CouchDB equivalent during a range query, the CouchDB world state incurs a cost in memory, network I/O and CPU utilization. In particular, use of a CouchDB world state for a range query is observed to result in significant increases in CPU and memory utilization in the peer, with an associated increase in network I/O as a result of communication with the CouchDB instance. When comparing the range query page sizes against a matching batch size in the Get Asset Batch Benchmark , it is observed to be more efficient to use a batch retrieval mechanism with known UUIDs.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/","text":"The pageinated rich query enchmark consists of evaluating paginatedRichQuery gateway transactions for the fixed-asset smart contract deployed within a CouchDB network that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database based on the following Mango query that matches an index created in CouchDB: { 'selector': { 'docType': 'fixed-asset', 'creator': 'clientId\u2019, 'bytesize': 'bytesize' } } Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog for each of the test clients. Successive rounds increase the page size of assets retrieved from the world state database. Benchmark Results Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 21.68 0.29 80.9 20 14.58 0.77 30.8 50 15.13 2.08 12.1 100 16.31 3.75 7.1 200 23.35 6.41 3.9 500 23.48 4.49 1.1 Benchmark Observations Increasing the page size of a rich query has significant impact on the achievable throughput and latency. This corresponds with significantly increased network I/O across the target peer, smart contract and the CouchDB world state database. Inspection of the resource utilization statistics for the individual benchmark runs show that the peer must deal with a significant network I/O load. This is a result of the peer obtaining and relaying the information from CouchDB to the smart contract transaction, and then passing back the resulting data from the smart contract transaction to the calling client application.","title":"Paginated Rich Query"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/#benchmark-results","text":"Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 21.68 0.29 80.9 20 14.58 0.77 30.8 50 15.13 2.08 12.1 100 16.31 3.75 7.1 200 23.35 6.41 3.9 500 23.48 4.49 1.1","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/#benchmark-observations","text":"Increasing the page size of a rich query has significant impact on the achievable throughput and latency. This corresponds with significantly increased network I/O across the target peer, smart contract and the CouchDB world state database. Inspection of the resource utilization statistics for the individual benchmark runs show that the peer must deal with a significant network I/O load. This is a result of the peer obtaining and relaying the information from CouchDB to the smart contract transaction, and then passing back the resulting data from the smart contract transaction to the calling client application.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/batch-create-asset/","text":"The batch create asset benchmark consists of submitting createAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a set of assets into the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog for each of the test clients. Successive rounds increase the batch size of the assets inserted into the world state database with a fixed asset size of 8Kb. Resource utilization is investigated for a fixed transaction rate of 15TPS and a batch size of 20. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.55 0.11 129.8 10 0.85 0.39 39.1 20 2.04 0.72 19.7 30 1.67 0.91 15.5 40 2.39 1.22 11.1 50 8.83 2.02 7.4 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.55 0.15 104.9 10 0.93 0.48 31.4 20 1.99 0.80 18.4 30 2.14 1.13 12.7 40 2.82 1.42 9.8 50 3.29 1.77 7.5 Resource Utilization- Batch Size 20 @15TPS Benchmark Observations Use of a LevelDB world state database is seen to enable higher throughput and lower latencies with small batch sizes, though this benefit is lost with large batch sizes. In comparing the resource utilization of a LevelDB world state database with a CouchDB equivalent during batch asset creation, there are similarities with the Create Asset Benchmark : implementing a CouchDB world state is CPU intensive, but is observed to be beneficial in terms of disc I/O.","title":"Batch Create Asset"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/batch-create-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.55 0.11 129.8 10 0.85 0.39 39.1 20 2.04 0.72 19.7 30 1.67 0.91 15.5 40 2.39 1.22 11.1 50 8.83 2.02 7.4 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.55 0.15 104.9 10 0.93 0.48 31.4 20 1.99 0.80 18.4 30 2.14 1.13 12.7 40 2.82 1.42 9.8 50 3.29 1.77 7.5 Resource Utilization- Batch Size 20 @15TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/batch-create-asset/#benchmark-observations","text":"Use of a LevelDB world state database is seen to enable higher throughput and lower latencies with small batch sizes, though this benefit is lost with large batch sizes. In comparing the resource utilization of a LevelDB world state database with a CouchDB equivalent during batch asset creation, there are similarities with the Create Asset Benchmark : implementing a CouchDB world state is CPU intensive, but is observed to be beneficial in terms of disc I/O.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/create-asset/","text":"The create asset benchmark consists of submitting createAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a single asset into the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog for each of the test clients. Successive rounds increase the size of the asset inserted into the world state database. Resource utilization is investigated for a fixed transaction rate of 125TPS and an asset size of 8Kb. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.48 0.11 372.5 2k 0.55 0.13 329.2 4k 0.60 0.14 294.7 8k 0.71 0.17 242.0 16k 0.76 0.23 177.6 32k 0.95 0.35 114.3 64k 1.45 0.62 61.2 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.71 0.22 194.0 2K 0.57 0.24 179.2 4K 0.54 0.26 164.1 8K 0.74 0.29 147.7 16K 0.88 0.36 119.9 32K 0.99 0.48 88.3 64K 1.58 0.77 51.7 Resource Utilization- 8k Assets @125TPS Benchmark Observations LevelDB facilitates asset addition at higher TPS and lower latencies than CouchDB. The throughput advantage of LevelDB is lessened with large asset sizes, but the latency advantage is retained. In comparing the resource utilization of a LevelDB world state database with a CouchDB equivalent during asset creation, a CouchDB world state is CPU intensive, but is beneficial in terms of disc I/O.","title":"Create Asset"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/create-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.48 0.11 372.5 2k 0.55 0.13 329.2 4k 0.60 0.14 294.7 8k 0.71 0.17 242.0 16k 0.76 0.23 177.6 32k 0.95 0.35 114.3 64k 1.45 0.62 61.2 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.71 0.22 194.0 2K 0.57 0.24 179.2 4K 0.54 0.26 164.1 8K 0.74 0.29 147.7 16K 0.88 0.36 119.9 32K 0.99 0.48 88.3 64K 1.58 0.77 51.7 Resource Utilization- 8k Assets @125TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/create-asset/#benchmark-observations","text":"LevelDB facilitates asset addition at higher TPS and lower latencies than CouchDB. The throughput advantage of LevelDB is lessened with large asset sizes, but the latency advantage is retained. In comparing the resource utilization of a LevelDB world state database with a CouchDB equivalent during asset creation, a CouchDB world state is CPU intensive, but is beneficial in terms of disc I/O.","title":"Benchmark Observations"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/empty-contract/","text":"The Empty Contract Benchmark consists of submitting emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. When submitting emptyContract gateway transactions, the interaction is recorded on the ledger. This results in the transaction pathway as depicted in Figure 1. Figure 1: Submit Empty Contract Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 15 transactions for each of the test clients. Resource utilization is investigated for fixed TPS rate of 350TPS. Benchmark Results LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 0.41 0.09 485.4 submit 2-of-any 0.33 0.10 420.0 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 0.52 0.11 380.5 submit 2-of-any 0.32 0.13 338.7 LevelDB Resource Utilization\u2013 Submit By Policy @350TPS CouchDB Resource Utilization\u2013 Submit By Policy @350TPS Resource Utilization\u2013 Submit 1ofAny Policy @350TPS Resource Utilization\u2013 Submit 2ofAny Policy @350TPS Benchmark Observations LevelDB is observed to be beneficial for achievable throughput and reduced latencies in comparison to CouchDB during submission of an emptyContract gateway transaction for both investigated endorsement policies. With a fixed world state database, the endorsement policy is observed to impact the consumed resources when submitting a transaction. Increasing the number of required endorsements is observed to increase the CPU and network I/O, through inclusion of additional peers and smart contract containers required to participate in each transaction. In comparing a LevelDB world state database with a CouchDB equivalent, only the network I/O is observed to be equivalent when varying the endorsement policy. There is an observed penalty in additional memory, CPU and disc I/O requirements for the use of a CouchDB world state for the network as a whole, though the memory requirements of the peers are reduced.","title":"Empty Contract"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/empty-contract/#benchmark-results","text":"LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 0.41 0.09 485.4 submit 2-of-any 0.33 0.10 420.0 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 0.52 0.11 380.5 submit 2-of-any 0.32 0.13 338.7 LevelDB Resource Utilization\u2013 Submit By Policy @350TPS CouchDB Resource Utilization\u2013 Submit By Policy @350TPS Resource Utilization\u2013 Submit 1ofAny Policy @350TPS Resource Utilization\u2013 Submit 2ofAny Policy @350TPS","title":"Benchmark Results"},{"location":"fabric/performance/1.4.0/nodeContract/nodeSDK/submit/empty-contract/#benchmark-observations","text":"LevelDB is observed to be beneficial for achievable throughput and reduced latencies in comparison to CouchDB during submission of an emptyContract gateway transaction for both investigated endorsement policies. With a fixed world state database, the endorsement policy is observed to impact the consumed resources when submitting a transaction. Increasing the number of required endorsements is observed to increase the CPU and network I/O, through inclusion of additional peers and smart contract containers required to participate in each transaction. In comparing a LevelDB world state database with a CouchDB equivalent, only the network I/O is observed to be equivalent when varying the endorsement policy. There is an observed penalty in additional memory, CPU and disc I/O requirements for the use of a CouchDB world state for the network as a whole, though the memory requirements of the peers are reduced.","title":"Benchmark Observations"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/configuration/","text":"This report was generated using the following Hyperledger Fabric component levels: Fabric images: 2.0.0 Fabric chaincode: 2.0.0 Fabric SDK Node: 2.1.0 Machine Configuration Hyperledger Caliper at commit level dce54d41a9920fe132992779ac1720d3634dad15 was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Redhat EL 7.7-64 RAM: 2x 32GB Hynix 32GB DDR4 2Rx8 NON REG Processor: 3.8GHz Intel Xeon-CoffeeLake (E-2174G-Quadcore) Motherboard: SuperMicro X11SCW-F_R1.02 Firmware: 1.0b 8-30-2019 Network Card: SuperMicro AOC-STG-i4T HDD: Intel S3710 Series 800 GB Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 Notes The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Configuration"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/configuration/#machine-configuration","text":"Hyperledger Caliper at commit level dce54d41a9920fe132992779ac1720d3634dad15 was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Redhat EL 7.7-64 RAM: 2x 32GB Hynix 32GB DDR4 2Rx8 NON REG Processor: 3.8GHz Intel Xeon-CoffeeLake (E-2174G-Quadcore) Motherboard: SuperMicro X11SCW-F_R1.02 Firmware: 1.0b 8-30-2019 Network Card: SuperMicro AOC-STG-i4T HDD: Intel S3710 Series 800 GB Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1","title":"Machine Configuration"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/configuration/#notes","text":"The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Notes"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/batch-get-asset/","text":"The batch asset retrieval benchmark consists of evaluating getAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a set of assets, formed by a randomised selection of available UUIDs, from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 20 transactions for each of the 10 test clients. Successive rounds increase the batch size of the assets retrieved from the world state database with a fixed asset size of 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.42 0.54 361.5 10 3.75 1.68 59.5 20 5.84 3.32 35.3 30 9.07 4.33 24.1 40 11.59 5.11 17.2 50 14.83 6.41 14.1 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.4 0.45 341.3 10 3.94 1.9 51.3 20 5.66 2.81 33.4 30 9.55 4.73 20.5 40 11.63 5.21 16.6 50 14.96 6.32 13.4 Resource Utilization- Batch Size 20 @30TPS","title":"Batch Get Asset"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/batch-get-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.42 0.54 361.5 10 3.75 1.68 59.5 20 5.84 3.32 35.3 30 9.07 4.33 24.1 40 11.59 5.11 17.2 50 14.83 6.41 14.1 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.4 0.45 341.3 10 3.94 1.9 51.3 20 5.66 2.81 33.4 30 9.55 4.73 20.5 40 11.63 5.21 16.6 50 14.96 6.32 13.4 Resource Utilization- Batch Size 20 @30TPS","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/empty-contract/","text":"The Empty Contract Benchmark consists of evaluating emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. This will result on the transaction being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 100 transactions for each of the 10 test clients. Resource utilization is investigated for fixed TPS rate of 750TPS. Benchmark Results LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 1.18 0.39 1314.3 evaluate 2-of-any 1.30 0.50 1264.1 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 1.23 0.55 992.4 evaluate 2-of-any 1.14 0.52 1072.03 LevelDB Resource Utilization\u2013 Evaluate By Policy @750TPS CouchDB Resource Utilization\u2013 Evaluate By Policy @750TPS Resource Utilization\u2013 Evaluate 1ofAny Policy @750TPS Resource Utilization\u2013 Evaluate 2ofAny Policy @750TPS","title":"Empty Contract"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/empty-contract/#benchmark-results","text":"LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 1.18 0.39 1314.3 evaluate 2-of-any 1.30 0.50 1264.1 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 1.23 0.55 992.4 evaluate 2-of-any 1.14 0.52 1072.03 LevelDB Resource Utilization\u2013 Evaluate By Policy @750TPS CouchDB Resource Utilization\u2013 Evaluate By Policy @750TPS Resource Utilization\u2013 Evaluate 1ofAny Policy @750TPS Resource Utilization\u2013 Evaluate 2ofAny Policy @750TPS","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/get-asset/","text":"The asset retrieval benchmark consists of evaluating getAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a single asset with a randomised UUID from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 50 transactions for each of the 10 test clients running on LevelDB, and a constant transaction backlog of 100 transactions for each of the 10 test clients running on CouchDB. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.82 0.35 862.5 1K 1.25 0.78 458.8 2K 1.85 1.68 103.6 4K 1.51 0.87 381.4 8K 2.08 1.31 257.8 16K 2.21 1.14 226.3 32K 4.3 2.15 120.3 64K 9.16 6.45 31.7 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.34 0.56 658.4 1K 1.91 0.83 566.4 2K 1.86 1.11 353.2 4K 2.18 1.17 347.8 8K 2.12 1.27 249.7 16K 2.47 1.28 199.2 32K 4.3 2.25 109.7 64K 7.63 3.25 63.8","title":"Get Asset"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/get-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.82 0.35 862.5 1K 1.25 0.78 458.8 2K 1.85 1.68 103.6 4K 1.51 0.87 381.4 8K 2.08 1.31 257.8 16K 2.21 1.14 226.3 32K 4.3 2.15 120.3 64K 9.16 6.45 31.7 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.34 0.56 658.4 1K 1.91 0.83 566.4 2K 1.86 1.11 353.2 4K 2.18 1.17 347.8 8K 2.12 1.27 249.7 16K 2.47 1.28 199.2 32K 4.3 2.25 109.7 64K 7.63 3.25 63.8","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/paginated-range-query/","text":"The paginated range query benchmark consists of evaluating paginatedRangeQuery gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that use a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 2 transactions for each of the 4 test clients. Successive rounds increase the page size of assets retrieved from the world state database. Benchmark Results LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.71 0.21 39.6 20 1.07 0.46 18.5 50 3.49 1.68 5.2 100 6.64 3.81 2.3 200 20.43 9.05 1.0 300 29.72 15.31 0.5 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.67 0.18 37.3 20 0.70 0.35 18.9 50 2.27 1.35 5.0 100 5.14 2.84 2.4 200 12.68 7.32 0.8 300 19.70 12.07 0.4","title":"Paginated Range Query"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/paginated-range-query/#benchmark-results","text":"LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.71 0.21 39.6 20 1.07 0.46 18.5 50 3.49 1.68 5.2 100 6.64 3.81 2.3 200 20.43 9.05 1.0 300 29.72 15.31 0.5 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.67 0.18 37.3 20 0.70 0.35 18.9 50 2.27 1.35 5.0 100 5.14 2.84 2.4 200 12.68 7.32 0.8 300 19.70 12.07 0.4","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/","text":"The paginated rich query benchmark consists of evaluating paginatedRichQuery gateway transactions for the fixed-asset smart contract deployed within a CouchDB network that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database based on the following Mango query that matches an index created in CouchDB: { 'selector': { 'docType': 'fixed-asset', 'creator': 'clientId\u2019, 'bytesize': 'bytesize' } } Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 5 transactions for each of the 4 test clients. Successive rounds increase the page size of assets retrieved from the world state database. Benchmark Results Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 16.4 3.74 90.5 20 13.9 3.19 45.0 50 10.99 2.84 21.1 100 8.76 3.19 11.9 200 8.73 3.81 5.0 500 22.98 7.1 2.0","title":"Paginated Rich Query"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/#benchmark-results","text":"Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 16.4 3.74 90.5 20 13.9 3.19 45.0 50 10.99 2.84 21.1 100 8.76 3.19 11.9 200 8.73 3.81 5.0 500 22.98 7.1 2.0","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/batch-create-asset/","text":"The batch create asset benchmark consists of submitting createAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a set of assets into the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 5 transactions for each of the 4 test clients. Successive rounds increase the batch size of the assets inserted into the world state database with a fixed asset size of 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.31 0.25 59.0 10 1.18 0.78 19.2 20 2.61 1.51 10.2 30 5.21 2.39 6.2 40 8.63 3.3 4.6 50 9.76 4.29 3.4 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.29 0.22 59.9 10 1.05 0.65 22.6 20 2.18 1.27 11.6 30 3.59 1.97 7.2 40 8.06 2.92 4.7 50 6.65 3.73 3.9","title":"Batch Create Asset"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/batch-create-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.31 0.25 59.0 10 1.18 0.78 19.2 20 2.61 1.51 10.2 30 5.21 2.39 6.2 40 8.63 3.3 4.6 50 9.76 4.29 3.4 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.29 0.22 59.9 10 1.05 0.65 22.6 20 2.18 1.27 11.6 30 3.59 1.97 7.2 40 8.06 2.92 4.7 50 6.65 3.73 3.9","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/batch-delete-asset/","text":"The batch delete asset benchmark consists of submitting deleteAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction deletes a set of assets, formed by a randomised selection of available UUIDs, from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 20 transactions for each of the 10 test clients. Successive rounds increase the batch size of the assets deleted from the world state database with a fixed asset size of 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.51 0.36 115.2 10 0.87 0.56 105.9 20 1.07 0.79 97.4 30 2.27 0.88 32.4 40 1.84 0.90 30.8 50 0.68 0.65 7.0 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.42 0.29 135.1 10 1.43 0.68 77.5 20 0.95 0.73 103.8 30 0.72 0.59 6.3 40 2.86 1.42 28.4 50 0.84 0.78 7.1","title":"Batch Delete Asset"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/batch-delete-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.51 0.36 115.2 10 0.87 0.56 105.9 20 1.07 0.79 97.4 30 2.27 0.88 32.4 40 1.84 0.90 30.8 50 0.68 0.65 7.0 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.42 0.29 135.1 10 1.43 0.68 77.5 20 0.95 0.73 103.8 30 0.72 0.59 6.3 40 2.86 1.42 28.4 50 0.84 0.78 7.1","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/create-asset/","text":"The create asset benchmark consists of submitting createAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a single asset into the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 10 transactions for each of the 10 test clients running on LevelDB, and a constant transaction backlog of 100 transactions for each of the 10 test clients running on CouchDB. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.61 0.32 219.7 2K 0.61 0.33 205.6 4K 0.63 0.35 198.4 8K 0.56 0.34 199.4 16K 0.88 0.48 123.8 32K 2.3 1.12 50.7 64K 4.2 1.93 30.6 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.43 0.3 111.0 2K 0.5 0.3 110.0 4K 0.4 0.3 109.9 8K 0.41 0.31 109.6 16K 0.58 0.35 99.6 32K 1.27 0.67 49.4 64K 2.46 1.13 28.2","title":"Create Asset"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/create-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.61 0.32 219.7 2K 0.61 0.33 205.6 4K 0.63 0.35 198.4 8K 0.56 0.34 199.4 16K 0.88 0.48 123.8 32K 2.3 1.12 50.7 64K 4.2 1.93 30.6 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.43 0.3 111.0 2K 0.5 0.3 110.0 4K 0.4 0.3 109.9 8K 0.41 0.31 109.6 16K 0.58 0.35 99.6 32K 1.27 0.67 49.4 64K 2.46 1.13 28.2","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/delete-asset/","text":"The delete asset benchmark consists of submitting deleteAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction deletes a single asset with a randomised UUID from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 20 transactions for each of the 5 test clients running on LevelDB, and a constant transaction backlog of 100 transactions for each of the 5 test clients running on CouchDB. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.27 0.25 124.8 1K 0.26 0.25 142.8 2K 0.26 0.25 144.1 4K 0.26 0.25 144.4 8K 0.26 0.25 152.9 16K 0.27 0.25 129.4 32K 0.26 0.24 137.7 64K 0.26 0.25 148.4 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 3 2.56 21.8 1K 9.73 2.64 31.4 2K 3.29 2.68 22.4 4K 3.05 2.61 21.5 8K 2.97 2.59 22.2 16K 3.07 2.59 21.9 32K 2.92 2.59 21.6 64K 3.12 2.66 20.3","title":"Delete Asset"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/delete-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.27 0.25 124.8 1K 0.26 0.25 142.8 2K 0.26 0.25 144.1 4K 0.26 0.25 144.4 8K 0.26 0.25 152.9 16K 0.27 0.25 129.4 32K 0.26 0.24 137.7 64K 0.26 0.25 148.4 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 3 2.56 21.8 1K 9.73 2.64 31.4 2K 3.29 2.68 22.4 4K 3.05 2.61 21.5 8K 2.97 2.59 22.2 16K 3.07 2.59 21.9 32K 2.92 2.59 21.6 64K 3.12 2.66 20.3","title":"Benchmark Results"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/empty-contract/","text":"The Empty Contract Benchmark consists of submitting emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. When submitting emptyContract gateway transactions, the interaction is recorded on the ledger. This results in the transaction pathway as depicted in Figure 1. Figure 1: Submit Empty Contract Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 100 transactions for each of the 10 test clients. Resource utilization is investigated for fixed TPS rate of 350TPS and 300TPS. Benchmark Results LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 1.97 0.99 569.5 submit 2-of-any 2.02 0.99 556.4 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 3.85 1.39 407.3 submit 2-of-any 3.06 1.45 420.9 LevelDB Resource Utilization\u2013 Submit By Policy @350TPS CouchDB Resource Utilization\u2013 Submit By Policy @350TPS Resource Utilization\u2013 Submit 1ofAny Policy @350TPS Resource Utilization\u2013 Submit 2ofAny Policy @350TPS","title":"Empty Contract"},{"location":"fabric/performance/2.0.0/nodeContract/nodeSDK/submit/empty-contract/#benchmark-results","text":"LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 1.97 0.99 569.5 submit 2-of-any 2.02 0.99 556.4 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 3.85 1.39 407.3 submit 2-of-any 3.06 1.45 420.9 LevelDB Resource Utilization\u2013 Submit By Policy @350TPS CouchDB Resource Utilization\u2013 Submit By Policy @350TPS Resource Utilization\u2013 Submit 1ofAny Policy @350TPS Resource Utilization\u2013 Submit 2ofAny Policy @350TPS","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/configuration/","text":"This report was generated using the following Hyperledger Fabric component levels: Fabric images: 2.1.0 fabric-chaincode-go: v0.0.0-20200424173110-d7076418f212 fabric-contract-api-go: v1.1.0 fabric-sdk-node: 2.1.0 Machine Configuration Hyperledger Caliper version 0.3.2 was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Redhat EL 7.7-64 RAM: 2x 32GB Hynix 32GB DDR4 2Rx8 NON REG Processor: 3.8GHz Intel Xeon-CoffeeLake (E-2174G-Quadcore) Motherboard: SuperMicro X11SCW-F_R1.02 Firmware: 1.0b 8-30-2019 Network Card: SuperMicro AOC-STG-i4T HDD: Intel S3710 Series 800 GB Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 Notes The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Configuration"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/configuration/#machine-configuration","text":"Hyperledger Caliper version 0.3.2 was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Redhat EL 7.7-64 RAM: 2x 32GB Hynix 32GB DDR4 2Rx8 NON REG Processor: 3.8GHz Intel Xeon-CoffeeLake (E-2174G-Quadcore) Motherboard: SuperMicro X11SCW-F_R1.02 Firmware: 1.0b 8-30-2019 Network Card: SuperMicro AOC-STG-i4T HDD: Intel S3710 Series 800 GB Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1","title":"Machine Configuration"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/configuration/#notes","text":"The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Notes"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/batch-get-asset/","text":"The batch asset retrieval benchmark consists of evaluating getAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a set of 8k byte size assets, formed by a randomised selection of available UUIDs, from the world state database. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.29 0.68 722.0 10 2.45 1.55 303.4 20 3.06 1.83 247.0 30 3.97 2.48 208.3 40 5.06 2.94 175.5 50 5.83 3.25 149.8 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.65 1.06 412.2 10 4.11 2.69 144.1 20 5.69 3.48 106.8 30 10.21 5.44 60.1 50 16.03 7.97 40.7 Benchmark Configuration File Click to expand LevelDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-batch-evaluate-1-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 1 UUID that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 8000 assets: 8000 bytesize: 8000 batchsize: 1 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-10-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 10 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 8000 assets: 8000 bytesize: 8000 batchsize: 10 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-30-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 30 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 30 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-40-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 40 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 40 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-50-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 50 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 50 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 30 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-batch-evaluate-1-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 1 UUID that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset create_sizes: - 8000 assets: 8000 bytesize: 8000 batchsize: 1 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-10-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 10 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 10 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-30-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 30 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 30 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-40-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 40 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 40 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-50-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 50 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 50 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 30 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js","title":"Batch Get Asset"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/batch-get-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.29 0.68 722.0 10 2.45 1.55 303.4 20 3.06 1.83 247.0 30 3.97 2.48 208.3 40 5.06 2.94 175.5 50 5.83 3.25 149.8 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.65 1.06 412.2 10 4.11 2.69 144.1 20 5.69 3.48 106.8 30 10.21 5.44 60.1 50 16.03 7.97 40.7","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/batch-get-asset/#benchmark-configuration-file","text":"Click to expand LevelDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-batch-evaluate-1-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 1 UUID that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 8000 assets: 8000 bytesize: 8000 batchsize: 1 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-10-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 10 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 8000 assets: 8000 bytesize: 8000 batchsize: 10 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-30-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 30 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 30 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-40-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 40 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 40 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-50-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 50 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 50 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 30 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-batch-evaluate-1-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 1 UUID that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset create_sizes: - 8000 assets: 8000 bytesize: 8000 batchsize: 1 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-10-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 10 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 10 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-30-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 30 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 30 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-40-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 40 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 40 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-50-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 50 UUIDs that each match an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 80 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 50 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js - label: get-asset-batch-evaluate-20-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAssetsFromBatch`. This method performs a getState on a batch of 20 UUIDs that each match an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 30 arguments: chaincodeID: fixed-asset nosetup: true assets: 8000 bytesize: 8000 batchsize: 20 consensus: false callback: benchmarks/api/fabric/lib/batch-get-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/empty-contract/","text":"The Empty Contract Benchmark consists of evaluating emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. This will result on the transaction being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Benchmark Results LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 1.44 0.36 1800.1 evaluate 2-of-any 1.35 0.37 1798.1 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.77 0.39 1185.1 evaluate 2-of-any 0.73 0.36 1381.9 Benchmark Configuration File Click to expand LevelDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand LevelDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 startingTps: 10 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js","title":"Empty Contract"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/empty-contract/#benchmark-results","text":"LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 1.44 0.36 1800.1 evaluate 2-of-any 1.35 0.37 1798.1 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.77 0.39 1185.1 evaluate 2-of-any 0.73 0.36 1381.9","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/empty-contract/#benchmark-configuration-file","text":"Click to expand LevelDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand LevelDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-evaluate description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `emptyContract`, which immediately returns a null response. This represents the fastest possible round trip time for an evaluateTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 startingTps: 10 arguments: chaincodeID: fixed-asset consensus: false callback: benchmarks/api/fabric/lib/empty-contract.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/get-asset/","text":"The asset retrieval benchmark consists of evaluating getAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a single asset with a randomised UUID from the world state database. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.95 0.25 1445.4 1k 1.19 0.38 1060.4 2k 0.96 0.33 1217.1 4k 1.17 0.70 579.5 8k 1.35 0.77 493.5 16k 1.38 0.79 606.9 32k 1.90 1.44 244.9 64k 2.11 1.37 324.5 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.61 0.80 835.6 1k 1.75 1.11 568.5 2k 1.85 1.30 393.0 4k 2.03 1.19 558.2 8k 2.11 1.36 398.9 16k 2.33 1.60 293.9 32k 2.48 1.59 293.6 64k 2.77 1.81 252.1 Benchmark Configuration File Click to expand LevelDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 100 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 1000 bytesize: 100 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-1000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 1000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 1000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-2000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 2000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 2000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-4000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 4000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 4000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-16000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 16000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 16000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-32000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 32000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 32000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-64000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 64000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 64000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 350 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 100 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 1000 bytesize: 100 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-1000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 1000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 1000 bytesize: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-2000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 2000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 2000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-4000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 4000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 4000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-16000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 16000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 16000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-32000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 32000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 32000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-64000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 64000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 64000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 350 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js","title":"Get Asset"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/get-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.95 0.25 1445.4 1k 1.19 0.38 1060.4 2k 0.96 0.33 1217.1 4k 1.17 0.70 579.5 8k 1.35 0.77 493.5 16k 1.38 0.79 606.9 32k 1.90 1.44 244.9 64k 2.11 1.37 324.5 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.61 0.80 835.6 1k 1.75 1.11 568.5 2k 1.85 1.30 393.0 4k 2.03 1.19 558.2 8k 2.11 1.36 398.9 16k 2.33 1.60 293.9 32k 2.48 1.59 293.6 64k 2.77 1.81 252.1","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/get-asset/#benchmark-configuration-file","text":"Click to expand LevelDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 100 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 1000 bytesize: 100 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-1000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 1000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 1000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-2000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 2000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 2000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-4000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 4000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 4000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-16000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 16000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 16000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-32000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 32000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 32000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-64000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 64000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 64000 uuid: '500' consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 350 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-asset-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 100 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 1000 bytesize: 100 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-1000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 1000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true assets: 1000 bytesize: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-2000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 2000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 2000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-4000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 4000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 4000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-16000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 16000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 16000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-32000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 32000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 32000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-64000 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 64000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 100 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 64000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js - label: get-asset-evaluate-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `getAsset`. This method performs a getState on an item that matches an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 350 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/paginated-range-query/","text":"The paginated range query benchmark consists of evaluating paginatedRangeQuery gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that use a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database. Benchmark Results LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 1.12 0.36 283.5 20 1.48 0.49 182.6 50 1.65 0.74 87.4 100 2.91 1.25 48.5 200 5.21 2.35 26.3 300 6.78 3.19 17.2 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 1.78 0.43 127.6 20 2.16 0.54 83.2 50 2.67 0.82 44.8 100 3.66 1.27 26.7 200 4.36 2.30 14.7 300 6.27 3.45 9.7 Benchmark Configuration File Click to expand LevelDB Benchmark Configuration workers: type: local number: 5 rounds: - label: mixed-range-query-evaluate-10 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 10 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 8000 range: 200 offset: 100 pagesize: '10' nomatch: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-50 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 50 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '50' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 100 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '100' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-200 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 200 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '200' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-300 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 500 and a range keys that bound 500 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '300' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: mixed-range-query-evaluate-10 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 10 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 8000 range: 200 offset: 100 pagesize: '10' nomatch: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-50 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 50 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '50' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 100 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '100' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-200 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 200 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '200' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-300 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 500 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '300' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js","title":"Paginated Range Query"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/paginated-range-query/#benchmark-results","text":"LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 1.12 0.36 283.5 20 1.48 0.49 182.6 50 1.65 0.74 87.4 100 2.91 1.25 48.5 200 5.21 2.35 26.3 300 6.78 3.19 17.2 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 1.78 0.43 127.6 20 2.16 0.54 83.2 50 2.67 0.82 44.8 100 3.66 1.27 26.7 200 4.36 2.30 14.7 300 6.27 3.45 9.7","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/paginated-range-query/#benchmark-configuration-file","text":"Click to expand LevelDB Benchmark Configuration workers: type: local number: 5 rounds: - label: mixed-range-query-evaluate-10 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 10 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 8000 range: 200 offset: 100 pagesize: '10' nomatch: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-50 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 50 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '50' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 100 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '100' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-200 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 200 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '200' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-300 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 500 and a range keys that bound 500 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 20 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '300' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: mixed-range-query-evaluate-10 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 10 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 8000 range: 200 offset: 100 pagesize: '10' nomatch: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-50 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 50 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '50' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 100 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '100' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-200 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 200 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '200' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-300 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 500 and a range keys that bound 200 assets created by the calling client. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '300' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js - label: mixed-range-query-evaluate-20-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRangeQuery`. This method performs a paginated range query, with a passed pagesize of 20 and a range keys that bound 200 assets created by the calling client at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 10 arguments: chaincodeID: fixed-asset range: 200 offset: 100 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-range-query-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/paginated-rich-query/","text":"The paginated rich query benchmark consists of evaluating paginatedRichQuery gateway transactions for the fixed-asset smart contract deployed within a CouchDB network that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database based on the following Mango query that matches an index created in CouchDB: { 'selector': { 'docType': 'fixed-asset', 'creator': 'clientId', 'bytesize': 'bytesize' } } Benchmark Results Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 20.54 6.59 107.0 20 22.07 7.04 81.7 50 23.43 7.55 52.4 100 27.23 8.08 35.3 200 23.20 7.83 19.4 500 23.43 7.40 8.9 Benchmark Configuration File Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: mixed-rich-query-evaluate-10 description: >- Test a evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 10 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 assets: 8000 pagesize: '10' consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-20 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 20 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-50 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 50 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '50' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 100 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '100' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-200 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 200 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '200' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-500 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 500 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '500' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js","title":"Paginated Rich Query"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/paginated-rich-query/#benchmark-results","text":"Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 20.54 6.59 107.0 20 22.07 7.04 81.7 50 23.43 7.55 52.4 100 27.23 8.08 35.3 200 23.20 7.83 19.4 500 23.43 7.40 8.9","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/evaluate/paginated-rich-query/#benchmark-configuration-file","text":"Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: mixed-rich-query-evaluate-10 description: >- Test a evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 10 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 assets: 8000 pagesize: '10' consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-20 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 20 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '20' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-50 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 50 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '50' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 100 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '100' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-200 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 200 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '200' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js - label: mixed-rich-query-evaluate-500 description: >- Test an evaluateTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `paginatedRichQuery`. This method performs a paginated rich query, with a passed pagesize of 500 and query string that matches all assets created by the calling client. Each returned asset is of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 5 startingTps: 5 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 pagesize: '500' nosetup: true consensus: false callback: benchmarks/api/fabric/lib/mixed-rich-query-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/batch-create-asset/","text":"The batch create asset benchmark consists of submitting createAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a set of 8k byte sized assets into the world state database. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.56 0.36 378.8 10 2.96 1.60 73.8 20 6.31 3.15 39.7 30 6.49 3.88 27.3 40 6.67 3.75 24.8 50 8.16 4.53 17.2 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.55 0.35 247.4 10 2.78 1.63 49.6 20 5.41 2.86 25.1 30 7.83 4.17 17.8 40 11.78 6.16 11.9 50 14.26 7.22 10.5 Benchmark Configuration File Click to expand LevelDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-batch-20-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-1-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 1 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 1 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-10-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 10 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 10 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-20-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-30-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 30 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 35 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 30 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-40-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 40 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 30 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 40 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-50-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 50 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 50 callback: benchmarks/api/fabric/lib/batch-create-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-batch-20-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 5 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-1-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 1 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 1 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-10-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 10 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 10 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-20-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-30-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 30 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 30 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-40-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 40 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 40 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-50-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 50 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 50 callback: benchmarks/api/fabric/lib/batch-create-asset.js","title":"Batch Create Asset"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/batch-create-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.56 0.36 378.8 10 2.96 1.60 73.8 20 6.31 3.15 39.7 30 6.49 3.88 27.3 40 6.67 3.75 24.8 50 8.16 4.53 17.2 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.55 0.35 247.4 10 2.78 1.63 49.6 20 5.41 2.86 25.1 30 7.83 4.17 17.8 40 11.78 6.16 11.9 50 14.26 7.22 10.5","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/batch-create-asset/#benchmark-configuration-file","text":"Click to expand LevelDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-batch-20-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-1-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 1 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 1 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-10-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 10 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 10 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-20-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 40 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-30-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 30 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 35 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 30 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-40-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 40 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 30 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 40 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-50-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 50 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 50 callback: benchmarks/api/fabric/lib/batch-create-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-batch-20-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 5 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-1-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 1 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 1 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-10-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 10 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 10 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-20-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 20 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 20 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-30-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 30 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 30 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-40-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 40 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 40 callback: benchmarks/api/fabric/lib/batch-create-asset.js - label: create-asset-batch-50-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAssetsFromBatch`, which inserts a batch of 50 assets of size 8k bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset bytesize: 8000 batchsize: 50 callback: benchmarks/api/fabric/lib/batch-create-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/create-asset/","text":"The create asset benchmark consists of submitting createAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a single asset into the world state database. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.39 0.27 592.6 1k 0.40 0.28 571.5 4k 0.56 0.36 458.7 8k 0.66 0.44 387.0 16k 0.95 0.61 266.6 32k 1.30 0.89 177.4 64k 2.44 1.31 117.4 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.73 0.47 350.6 1k 0.78 0.51 328.7 4k 0.87 0.57 293.3 8k 0.98 0.64 256.8 16k 1.46 0.86 187.3 24k 1.83 1.10 149.7 32k 2.12 1.26 125.8 64k 3.23 2.08 74.8 Benchmark Configuration File Click to expand LevelDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database at a fixed TPS rate. chaincodeID: fixed-asset txDuration: 30 rateControl: type: fixed-rate opts: tps: 15 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-100 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 100 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 100 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-1000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 1000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 1000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-4000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 4000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 4000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-16000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 16000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 16000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-32000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 32000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 32000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-64000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 64000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 64000 callback: benchmarks/api/fabric/lib/create-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database at a fixed TPS rate. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 15 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-100 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 100 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 100 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-1000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 1000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 1000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-4000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 4000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 4000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-16000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 16000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 16000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-24000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 24000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 24000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-32000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 32000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 32000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-64000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 64000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 64000 callback: benchmarks/api/fabric/lib/create-asset.js","title":"Create Asset"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/create-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.39 0.27 592.6 1k 0.40 0.28 571.5 4k 0.56 0.36 458.7 8k 0.66 0.44 387.0 16k 0.95 0.61 266.6 32k 1.30 0.89 177.4 64k 2.44 1.31 117.4 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.73 0.47 350.6 1k 0.78 0.51 328.7 4k 0.87 0.57 293.3 8k 0.98 0.64 256.8 16k 1.46 0.86 187.3 24k 1.83 1.10 149.7 32k 2.12 1.26 125.8 64k 3.23 2.08 74.8","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/create-asset/#benchmark-configuration-file","text":"Click to expand LevelDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database at a fixed TPS rate. chaincodeID: fixed-asset txDuration: 30 rateControl: type: fixed-rate opts: tps: 15 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-100 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 100 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 100 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-1000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 1000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 1000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-4000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 4000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 4000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-16000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 16000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 16000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-32000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 32000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 32000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-64000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 64000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 arguments: chaincodeID: fixed-asset bytesize: 64000 callback: benchmarks/api/fabric/lib/create-asset.js Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-asset-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database at a fixed TPS rate. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 15 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-100 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 100 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 100 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-1000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 1000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 1000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-4000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 4000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 4000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-8000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 8000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-16000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 16000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 16000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-24000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 24000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 24000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-32000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 32000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 32000 callback: benchmarks/api/fabric/lib/create-asset.js - label: create-asset-64000 description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `createAsset`, which inserts an asset of size 64000 bytes into the World State database. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 50 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 64000 callback: benchmarks/api/fabric/lib/create-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/empty-contract/","text":"The Empty Contract Benchmark consists of submitting emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. When submitting emptyContract gateway transactions, the interaction is recorded on the ledger. This results in the transaction pathway as depicted in Figure 1. Figure 1: Submit Empty Contract Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Benchmark Results LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 2.96 1.54 692.1 submit 2-of-any 2.80 1.59 676.9 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 3.76 1.70 605.3 submit 2-of-any 3.28 1.77 637.4 Benchmark Configuration File Click to expand LevelDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand LevelDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 startingTps: 10 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js","title":"Empty Contract"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/empty-contract/#benchmark-results","text":"LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 2.96 1.54 692.1 submit 2-of-any 2.80 1.59 676.9 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 3.76 1.70 605.3 submit 2-of-any 3.28 1.77 637.4","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/goContract/nodeSDK/submit/empty-contract/#benchmark-configuration-file","text":"Click to expand LevelDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand LevelDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 1OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js Click to expand CouchDB 2OF Benchmark Configuration workers: type: local number: 10 rounds: - label: empty-contract-submit description: >- Test a submitTransaction() Gateway method against the Go `fixed-asset` Smart Contract method named `nullResponse`, which immediately returns a null response. This represents the fastest possible round trip time for a submitTransaction() method that does not touch the world state or perform any action. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 200 startingTps: 10 arguments: chaincodeID: fixed-asset consensus: true callback: benchmarks/api/fabric/lib/empty-contract.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/configuration/","text":"This report was generated using the following Hyperledger Fabric component levels: Fabric images: 2.1.0 Fabric chaincode node: 2.1.0 Fabric SDK Node: 2.1.0 Machine Configuration Hyperledger Caliper at commit level dce54d41a9920fe132992779ac1720d3634dad15 was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Redhat EL 7.7-64 RAM: 2x 32GB Hynix 32GB DDR4 2Rx8 NON REG Processor: 3.8GHz Intel Xeon-CoffeeLake (E-2174G-Quadcore) Motherboard: SuperMicro X11SCW-F_R1.02 Firmware: 1.0b 8-30-2019 Network Card: SuperMicro AOC-STG-i4T HDD: Intel S3710 Series 800 GB Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1 Notes The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Configuration"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/configuration/#machine-configuration","text":"Hyperledger Caliper at commit level dce54d41a9920fe132992779ac1720d3634dad15 was used. The report was generated on an IBM Cloud Softlayer machine with the following configuration: OS: Redhat EL 7.7-64 RAM: 2x 32GB Hynix 32GB DDR4 2Rx8 NON REG Processor: 3.8GHz Intel Xeon-CoffeeLake (E-2174G-Quadcore) Motherboard: SuperMicro X11SCW-F_R1.02 Firmware: 1.0b 8-30-2019 Network Card: SuperMicro AOC-STG-i4T HDD: Intel S3710 Series 800 GB Architecture: x86_64 CPU op-mode(s): 32-bit, 64-bit Byte Order: Little Endian CPU(s): 8 On-line CPU(s) list: 0-7 Thread(s) per core: 2 Core(s) per socket: 4 Socket(s): 1","title":"Machine Configuration"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/configuration/#notes","text":"The performance information is obtained by measuring the transaction throughput for different types of smart contract transactions. The term \u201ctransaction\u201d is used in a generic sense, and refers to any interaction with a smart contract, regardless of the complexity of the subsequent interaction(s) with the blockchain platform. Measuring transaction throughput demonstrates potential transaction rates, and the impact of the relative cost of different Hyperledger Fabric Stub API calls. The data contained in the reports was measured in a controlled environment, results obtained in other environments might vary. For more details on the environments used, see the resources at the end of this report. The performance data cannot be compared across versions of Hyperledger Fabric, as testing hardware and environments may have changed significantly. The testing contents and processing methodologies may have also changed between performance reports, and so cannot be compared.","title":"Notes"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/batch-get-asset/","text":"The batch asset retrieval benchmark consists of evaluating getAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a set of assets, formed by a randomised selection of available UUIDs, from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 20 transactions for each of the 10 test clients. Successive rounds increase the batch size of the assets retrieved from the world state database with a fixed asset size of 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.27 0.46 384.8 10 3.54 1.66 58.7 20 5.39 2.75 37.8 30 9.42 4.98 18.9 40 11.07 5.67 17.0 50 13.71 6.00 14.3 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.17 0.41 363.2 10 4.03 1.93 53.4 20 5.80 2.93 35.3 30 9.80 4.80 21.0 40 11.73 5.22 17.4 50 15.13 6.42 13.4 Resource Utilization- Batch Size 20 @30TPS","title":"Batch Get Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/batch-get-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.27 0.46 384.8 10 3.54 1.66 58.7 20 5.39 2.75 37.8 30 9.42 4.98 18.9 40 11.07 5.67 17.0 50 13.71 6.00 14.3 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 1.17 0.41 363.2 10 4.03 1.93 53.4 20 5.80 2.93 35.3 30 9.80 4.80 21.0 40 11.73 5.22 17.4 50 15.13 6.42 13.4 Resource Utilization- Batch Size 20 @30TPS","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/empty-contract/","text":"The Empty Contract Benchmark consists of evaluating emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. This will result on the transaction being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 100 transactions for each of the 10 test clients. Resource utilization is investigated for fixed TPS rate of 750TPS. Benchmark Results LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.75 0.33 1387.3 evaluate 2-of-any 0.80 0.32 1407.0 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.77 0.39 1185.1 evaluate 2-of-any 0.73 0.36 1381.9 LevelDB Resource Utilization\u2013 Evaluate By Policy @750TPS CouchDB Resource Utilization\u2013 Evaluate By Policy @750TPS Resource Utilization\u2013 Evaluate 1ofAny Policy @750TPS Resource Utilization\u2013 Evaluate 2ofAny Policy @750TPS","title":"Empty Contract"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/empty-contract/#benchmark-results","text":"LevelDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.75 0.33 1387.3 evaluate 2-of-any 0.80 0.32 1407.0 CouchDB- evaluate transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) evaluate 1-of-any 0.77 0.39 1185.1 evaluate 2-of-any 0.73 0.36 1381.9 LevelDB Resource Utilization\u2013 Evaluate By Policy @750TPS CouchDB Resource Utilization\u2013 Evaluate By Policy @750TPS Resource Utilization\u2013 Evaluate 1ofAny Policy @750TPS Resource Utilization\u2013 Evaluate 2ofAny Policy @750TPS","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/get-asset/","text":"The asset retrieval benchmark consists of evaluating getAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a single asset with a randomised UUID from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 50 transactions for each of the 10 test clients running on LevelDB, and a constant transaction backlog of 100 transactions for each of the 10 test clients running on CouchDB. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.95 0.39 811.2 1K 1.39 0.99 340.1 2K 1.56 1.17 322.4 4K 1.61 1.01 360.7 8K 1.83 1.07 292.4 16K 2.44 1.30 218.3 32K 4.38 2.48 96.5 64K 7.92 5.18 63.8 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.08 0.41 832.0 1K 1.25 0.71 539.1 2K 1.58 1.05 423.8 4K 2.03 1.51 264.3 8K 2.14 1.28 268.4 16K 2.42 1.29 215.9 32K 4.56 2.59 92.5 64K 8.35 5.82 63.6","title":"Get Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/get-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.95 0.39 811.2 1K 1.39 0.99 340.1 2K 1.56 1.17 322.4 4K 1.61 1.01 360.7 8K 1.83 1.07 292.4 16K 2.44 1.30 218.3 32K 4.38 2.48 96.5 64K 7.92 5.18 63.8 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.08 0.41 832.0 1K 1.25 0.71 539.1 2K 1.58 1.05 423.8 4K 2.03 1.51 264.3 8K 2.14 1.28 268.4 16K 2.42 1.29 215.9 32K 4.56 2.59 92.5 64K 8.35 5.82 63.6","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/get-private-asset/","text":"The asset retrieval benchmark consists of evaluating getPrivateAsset gateway transactions for the fixed-asset smart contract deployed within CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the Private Data Collection of the authorized organization, resulting in the pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a single asset with a randomised UUID from the Private Data Collection of the authorized organization. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 25 transactions for each of the 10 test clients running on CouchDB. Benchmark Results CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.36 0.50 703.3 1K 1.47 0.53 643.9 2K 1.75 0.75 454.5 4K 1.29 0.45 457.2 8K 2.49 1.20 259.2 16K 2.10 0.90 196.4 32K 3.81 1.27 112.6 64K 5.09 2.42 60.1 Benchmark Configuration File Click to expand CouchDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-private-asset-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 100 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 1000 bytesize: 100 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-1000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 1000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true assets: 1000 bytesize: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-2000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 2000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 2000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-4000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 4000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 4000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-8000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-16000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 16000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 16000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-32000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 32000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 32000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-64000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 64000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 64000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 350 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js","title":"Get Private Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/get-private-asset/#benchmark-results","text":"CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 1.36 0.50 703.3 1K 1.47 0.53 643.9 2K 1.75 0.75 454.5 4K 1.29 0.45 457.2 8K 2.49 1.20 259.2 16K 2.10 0.90 196.4 32K 3.81 1.27 112.6 64K 5.09 2.42 60.1","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/get-private-asset/#benchmark-configuration-file","text":"Click to expand CouchDB Benchmark Configuration workers: type: local number: 10 rounds: - label: get-private-asset-evaluate-100 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 100 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset create_sizes: - 100 - 1000 - 2000 - 4000 - 8000 - 16000 - 32000 - 64000 assets: 1000 bytesize: 100 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-1000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 1000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true assets: 1000 bytesize: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-2000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 2000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 2000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-4000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 4000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 4000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-8000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 8000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-16000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 16000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 16000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-32000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 32000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 32000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-64000 description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 64000 bytes. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 25 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 64000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js - label: get-private-asset-evaluate-8000-fixed-tps description: >- Test an evaluateTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `getPrivateAsset`. This method performs a getPrivateData on an item that matches an asset of size 8000 bytes at a fixed TPS. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 350 arguments: chaincodeID: fixed-asset nosetup: true bytesize: 8000 assets: 1000 consensus: false callback: benchmarks/api/fabric/lib/get-private-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/paginated-range-query/","text":"The paginated range query benchmark consists of evaluating paginatedRangeQuery gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that use a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 2 transactions for each of the 4 test clients. Successive rounds increase the page size of assets retrieved from the world state database. Benchmark Results LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.74 0.22 37.6 20 1.08 0.50 17.1 50 3.80 1.86 4.7 100 7.92 4.18 2.1 200 22.40 10.06 0.8 300 29.95 14.99 0.4 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 1.00 0.24 35.8 20 0.98 0.52 15.9 50 2.85 1.83 4.6 100 8.67 4.29 2.0 200 18.49 9.75 0.7 300 27.46 15.95 0.3","title":"Paginated Range Query"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/paginated-range-query/#benchmark-results","text":"LevelDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 0.74 0.22 37.6 20 1.08 0.50 17.1 50 3.80 1.86 4.7 100 7.92 4.18 2.1 200 22.40 10.06 0.8 300 29.95 14.99 0.4 CouchDB Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 1.00 0.24 35.8 20 0.98 0.52 15.9 50 2.85 1.83 4.6 100 8.67 4.29 2.0 200 18.49 9.75 0.7 300 27.46 15.95 0.3","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/","text":"The paginated rich query benchmark consists of evaluating paginatedRichQuery gateway transactions for the fixed-asset smart contract deployed within a CouchDB network that uses a 2-of-any endorsement policy. This will result in the method being run on a single Hyperledger Fabric Peer and will not result in any interaction with the Orderer. The investigated scenarios are targeted at reading from the world state database, resulting in the transaction pathway depicted in Figure 1. Figure 1: Evaluate Transaction Pathway Each transaction retrieves a fixed number of mixed byte size assets in the range [100, 1000, 2000, 4000, 8000, 16000, 32000, 64000] from the world state database based on the following Mango query that matches an index created in CouchDB: { 'selector': { 'docType': 'fixed-asset', 'creator': 'clientId', 'bytesize': 'bytesize' } } Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 5 transactions for each of the 4 test clients. Successive rounds increase the page size of assets retrieved from the world state database. Benchmark Results Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 17.43 4.31 99.6 20 12.82 3.53 45.9 50 10.54 3.23 19.8 100 10.14 3.72 10.0 200 10.33 4.90 5.1 500 19.65 8.64 1.8","title":"Paginated Rich Query"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/evaluate/paginated-rich-query/#benchmark-results","text":"Page Size Max Latency (s) Avg Latency (s) Throughput (TPS) 10 17.43 4.31 99.6 20 12.82 3.53 45.9 50 10.54 3.23 19.8 100 10.14 3.72 10.0 200 10.33 4.90 5.1 500 19.65 8.64 1.8","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/batch-create-asset/","text":"The batch create asset benchmark consists of submitting createAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a set of assets into the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 5 transactions for each of the 4 test clients. Successive rounds increase the batch size of the assets inserted into the world state database with a fixed asset size of 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.29 0.22 59.7 10 1.06 0.66 22.0 20 2.45 1.36 10.7 30 5.60 2.60 5.6 40 5.92 3.33 4.3 50 8.20 4.45 3.3 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.31 0.25 57.5 10 1.72 0.77 19.4 20 2.58 1.60 9.6 30 5.43 2.83 5.3 40 7.06 3.85 4.0 50 8.64 4.87 3.0","title":"Batch Create Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/batch-create-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.29 0.22 59.7 10 1.06 0.66 22.0 20 2.45 1.36 10.7 30 5.60 2.60 5.6 40 5.92 3.33 4.3 50 8.20 4.45 3.3 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.31 0.25 57.5 10 1.72 0.77 19.4 20 2.58 1.60 9.6 30 5.43 2.83 5.3 40 7.06 3.85 4.0 50 8.64 4.87 3.0","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/batch-delete-asset/","text":"The batch delete asset benchmark consists of submitting deleteAssetsFromBatch gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result on the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction deletes a set of assets, formed by a randomised selection of available UUIDs, from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 20 transactions for each of the 10 test clients. Successive rounds increase the batch size of the assets deleted from the world state database with a fixed asset size of 8Kb. Benchmark Results LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.42 0.28 134.8 10 0.95 0.66 99.0 20 1.25 0.80 78.6 30 0.58 0.57 6.5 40 2.38 1.30 25.7 50 0.74 0.64 6.5 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.79 0.45 100.6 10 2.79 1.38 53.9 20 4.95 2.49 39.8 30 7.28 3.16 18.3 40 9.52 4.56 17.9 50 8.84 2.93 11.6","title":"Batch Delete Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/batch-delete-asset/#benchmark-results","text":"LevelDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.42 0.28 134.8 10 0.95 0.66 99.0 20 1.25 0.80 78.6 30 0.58 0.57 6.5 40 2.38 1.30 25.7 50 0.74 0.64 6.5 CouchDB Batch Size Max Latency (s) Avg Latency (s) Throughput (TPS) 1 0.79 0.45 100.6 10 2.79 1.38 53.9 20 4.95 2.49 39.8 30 7.28 3.16 18.3 40 9.52 4.56 17.9 50 8.84 2.93 11.6","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/create-asset/","text":"The create asset benchmark consists of submitting createAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a single asset into the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 10 transactions for each of the 10 test clients running on LevelDB, and a constant transaction backlog of 100 transactions for each of the 10 test clients running on CouchDB. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.59 0.32 215.6 2K 0.59 0.33 208.5 4K 0.55 0.34 198.7 8K 0.62 0.34 201.4 16K 0.88 0.48 126.3 32K 2.46 1.14 50.9 64K 4.19 1.93 29.3 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.37 0.28 121.9 2K 0.39 0.30 112.1 4K 0.39 0.29 113.7 8K 0.39 0.30 111.0 16K 0.52 0.32 107.5 32K 1.26 0.65 50.3 64K 2.33 1.10 28.8","title":"Create Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/create-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.59 0.32 215.6 2K 0.59 0.33 208.5 4K 0.55 0.34 198.7 8K 0.62 0.34 201.4 16K 0.88 0.48 126.3 32K 2.46 1.14 50.9 64K 4.19 1.93 29.3 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.37 0.28 121.9 2K 0.39 0.30 112.1 4K 0.39 0.29 113.7 8K 0.39 0.30 111.0 16K 0.52 0.32 107.5 32K 1.26 0.65 50.3 64K 2.33 1.10 28.8","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/create-private-asset/","text":"The create private asset benchmark consists of submitting createPrivateAsset gateway transactions for the fixed-asset smart contract deployed within CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on Hyperledger Fabric Peers as required by the endorsement policy and a hash of the private data being appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the Private Data Collection of the authorized organization, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction inserts a single asset into the Private Data Collection of the authorized organization. Benchmark Results CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 2.11 1.55 18.4 1k 2.05 1.53 19.2 4k 2.06 1.42 20.3 8k 2.09 1.68 16.1 16k 2.10 1.70 16.2 32k 2.12 1.70 16.7 64k 2.23 1.78 15.5 Benchmark Configuration File Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-private-asset-100 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 100 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 100 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-1000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 1000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 1000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-4000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 4000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 4000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-8000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 8000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-16000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 16000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 16000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-32000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 32000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 32000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-64000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 64000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 64000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 8000 bytes into the Private Data Collection of the authorized organization at a fixed TPS rate. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 15 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-private-asset.js","title":"Create Private Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/create-private-asset/#benchmark-results","text":"CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 2.11 1.55 18.4 1k 2.05 1.53 19.2 4k 2.06 1.42 20.3 8k 2.09 1.68 16.1 16k 2.10 1.70 16.2 32k 2.12 1.70 16.7 64k 2.23 1.78 15.5","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/create-private-asset/#benchmark-configuration-file","text":"Click to expand CouchDB Benchmark Configuration workers: type: local number: 5 rounds: - label: create-private-asset-100 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 100 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 100 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-1000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 1000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 1000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-4000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 4000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 4000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-8000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 8000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-16000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 16000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 16000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-32000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 32000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 32000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-64000 description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 64000 bytes into the Private Data Collection of the authorized organization. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-backlog opts: unfinished_per_client: 10 startingTps: 1 arguments: chaincodeID: fixed-asset bytesize: 64000 callback: benchmarks/api/fabric/lib/create-private-asset.js - label: create-private-asset-8000-fixed-tps description: >- Test a submitTransaction() Gateway method against the NodeJS `fixed-asset` Smart Contract method named `createPrivateAsset`, which inserts an asset of size 8000 bytes into the Private Data Collection of the authorized organization at a fixed TPS rate. chaincodeID: fixed-asset txDuration: 300 rateControl: type: fixed-rate opts: tps: 15 arguments: chaincodeID: fixed-asset bytesize: 8000 callback: benchmarks/api/fabric/lib/create-private-asset.js","title":"Benchmark Configuration File"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/delete-asset/","text":"The delete asset benchmark consists of submitting deleteAsset gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks that uses a 2-of-any endorsement policy. This will result in the method being run on Hyperledger Fabric Peers as required by the endorsement policy and appended to the ledger by the Orderer. The investigated scenarios are targeted at writing to the world state database, resulting in the transaction pathway as depicted in Figure 1. Figure 1: Submit Transaction Pathway Each transaction deletes a single asset with a randomised UUID from the world state database. Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 20 transactions for each of the 5 test clients running on LevelDB, and a constant transaction backlog of 100 transactions for each of the 5 test clients running on CouchDB. Benchmark Results LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.27 0.25 130.2 1K 0.26 0.25 145.6 2K 0.26 0.24 144.8 4K 0.26 0.24 152.1 8K 0.26 0.25 157.4 16K 0.26 0.24 129.6 32K 0.27 0.25 160.0 64K 0.26 0.25 162.0 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.35 0.30 104.1 1K 0.34 0.29 117.5 2K 0.34 0.30 121.6 4K 0.35 0.29 123.5 8K 20.35 0.29 118.7 16K 0.33 0.29 109.5 32K 0.36 0.29 98.8 64K 0.38 0.32 123.8","title":"Delete Asset"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/delete-asset/#benchmark-results","text":"LevelDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.27 0.25 130.2 1K 0.26 0.25 145.6 2K 0.26 0.24 144.8 4K 0.26 0.24 152.1 8K 0.26 0.25 157.4 16K 0.26 0.24 129.6 32K 0.27 0.25 160.0 64K 0.26 0.25 162.0 CouchDB Asset Size (bytes) Max Latency (s) Avg Latency (s) Throughput (TPS) 100 0.35 0.30 104.1 1K 0.34 0.29 117.5 2K 0.34 0.30 121.6 4K 0.35 0.29 123.5 8K 20.35 0.29 118.7 16K 0.33 0.29 109.5 32K 0.36 0.29 98.8 64K 0.38 0.32 123.8","title":"Benchmark Results"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/empty-contract/","text":"The Empty Contract Benchmark consists of submitting emptyContract gateway transactions for the fixed-asset smart contract deployed within LevelDB and CouchDB networks. When submitting emptyContract gateway transactions, the interaction is recorded on the ledger. This results in the transaction pathway as depicted in Figure 1. Figure 1: Submit Empty Contract Transaction Pathway This is repeated for networks that use the following endorsement policies: 1-of-any 2-of-any Achievable throughput and associated latencies are investigated through maintaining a constant transaction backlog of 100 transactions for each of the 10 test clients. Resource utilization is investigated for fixed TPS rate of 350TPS and 300TPS. Benchmark Results LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 1.64 0.88 623.2 submit 2-of-any 1.53 0.86 633.2 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 2.36 0.98 575.4 submit 2-of-any 2.05 1.00 595.6 LevelDB Resource Utilization\u2013 Submit By Policy @350TPS CouchDB Resource Utilization\u2013 Submit By Policy @350TPS Resource Utilization\u2013 Submit 1ofAny Policy @350TPS Resource Utilization\u2013 Submit 2ofAny Policy @350TPS","title":"Empty Contract"},{"location":"fabric/performance/2.1.0/nodeContract/nodeSDK/submit/empty-contract/#benchmark-results","text":"LevelDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 1.64 0.88 623.2 submit 2-of-any 1.53 0.86 633.2 CouchDB- submit transactions with varying endorsement policy Type Policy Max Latency (s) Avg Latency (s) Throughput (TPS) submit 1-of-any 2.36 0.98 575.4 submit 2-of-any 2.05 1.00 595.6 LevelDB Resource Utilization\u2013 Submit By Policy @350TPS CouchDB Resource Utilization\u2013 Submit By Policy @350TPS Resource Utilization\u2013 Submit 1ofAny Policy @350TPS Resource Utilization\u2013 Submit 2ofAny Policy @350TPS","title":"Benchmark Results"}]}